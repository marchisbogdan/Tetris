{"version":3,"sources":["babelScript.js"],"names":["genMatrix","i","j","maxRow","matrix","maxColl","start","play","length","checkForFullRow","block","generateBlock","movingBlock","setInterval","reposition","intervalTime","stop","lastY","deleteLastPosition","alert","blockGen","document","createElement","className","style","background","generateBackgroundColor","startingPoz","appendChild","nextAvailableCell","getnextAvailableCell","DIR","down","xAxis","default","setThePositions","startingRow","startingColl","changeDirection","event","window","keyCode","verifyVacancy","left","back","moveTo","currentRow","currentColl","nextRow","nextColl","err","console","log","right","isGameOver","resetPositions","clearInterval","direction","goBack","minColl","isPositionOpen","currentBlock","Error","newBlock","lastX","parent","getElementsByClassName","removeChild","children","currentR","currentC","nextR","nextC","incrNextRow","incrNextColl","lastRow","lastColl","color","randNr","randomNumber","colors","detachEvents","full","clearLastRow","repositionBlocks","theLastRow","td","sourceRow","destRow","sourceColl","destColl","minVal","maxVal","Math","round","random","getElementById","removeEventListener","startButton","addEventListener","stopButton","lastPoz","lastOccupiedCell","omon"],"mappings":"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","file":"script.js","sourcesContent":["'use strict';\n\n(function () {\n\tvar startButton = document.getElementById('start');\n\tstartButton.addEventListener('click', start);\n\tvar stopButton = document.getElementById('stop');\n\tstopButton.addEventListener('click', stop);\n\t// adding the event for key press\n\tdocument.addEventListener('keydown', changeDirection);\n\tgenMatrix();\n})();\n\nvar play = true,\n    DIR = { left: -1, down: 0, right: 1 },\n\n\n// directions\nxAxis = { back: 1, default: 0 },\n\n\n// values for verical movement\nintervalTime = 800,\n\n\n// the period of time for an interval function call\n\nblock,\n\n\n// the current moving block\nmovingBlock,\n\n\n// for the repositioning the block after a certain time interval\n\n// used to trace the block, (using indexes to identify the right position easier)\nstartingRow = 1,\n    startingColl = 6,\n    currentRow = 1,\n    currentColl = 6,\n    lastRow = 1,\n    lastColl = 6,\n    nextRow = 2,\n    nextColl = 6,\n\n\n// positions in the matrix\nlastX = 6,\n    lastY = 1,\n    startingPoz = document.getElementsByClassName('coll-' + startingColl)[0],\n\n\n// this is a column in the first row of the table\nlastPoz,\n\n\n// the last position of the moving block\nnextAvailableCell,\n\n\n// the next available cell for the moving block\nlastOccupiedCell,\n\n\n// the last occupied cell for the moving block\n// global vars\nmaxRow = 15,\n    maxColl = 10,\n    minColl = 1,\n    matrix = [],\n\n\n// colors for the blocks background\ncolors = ['#be0000', '#becf00', '#2cbe00', '#001ebe', '#be009a']; // the colors of the moving block\n\nfunction genMatrix() {\n\tvar i, j;\n\tfor (i = 1; i <= maxRow; i++) {\n\t\tmatrix[i] = [];\n\t\tfor (j = 1; j <= maxColl; j++) {\n\t\t\tmatrix[i][j] = 0;\n\t\t}\n\t}\n}\n\nfunction start() {\n\tplay = true;\n\tif (matrix.length === 0) {\n\t\tgenMatrix();\n\t}\n\tcheckForFullRow();\n\tblock = generateBlock();\n\tmovingBlock = setInterval(reposition, intervalTime);\n}\n\nfunction stop() {\n\tplay = false;\n\tlastY += 1;\n\tdeleteLastPosition();\n\talert(\"Game stoped!\");\n}\n\n/*\n\tThe function creates a block, and sets a color to the block before appending\n\tit to the starting position of the board\n*/\nfunction generateBlock() {\n\tblockGen = document.createElement('div');\n\tblockGen.className = 'active-block';\n\tblockGen.style.background = generateBackgroundColor();\n\tstartingPoz.appendChild(blockGen);\n\tnextAvailableCell = getnextAvailableCell(DIR.down, xAxis.default);\n\n\tsetThePositions(startingRow, startingColl, startingRow, startingColl);\n\n\treturn blockGen;\n}\n\n/*\n\tthe function starts when a key is pressed and it directs a particular event to a coresponding case\n*/\nfunction changeDirection(event) {\n\tevent = event || window.event;\n\t//clearInterval(movingBlock);\n\tif (event.keyCode == '37') {\n\t\t// left arrow\n\t\tif (verifyVacancy(DIR.left, xAxis.back)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.left, xAxis.back);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.back, nextColl + DIR.left, nextRow, nextColl + DIR.left);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t} else if (event.keyCode == '39') {\n\t\t// right arrow\n\t\tif (verifyVacancy(DIR.right, xAxis.back)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.right, xAxis.back);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.back, nextColl + DIR.right, nextRow, nextColl + DIR.right);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t} else if (event.keyCode == '40') {\n\t\t// down arrow\n\t\tif (verifyVacancy(DIR.down, xAxis.default)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.down, xAxis.default);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.default, nextColl + DIR.down);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t}\n}\n/*\n\tif there is an available position next the function will reposition the block,\n\totherwise it will clear the last position and create a new block from the beginning\n*/\nfunction reposition() {\n\n\tif (play && isGameOver() === true) {\n\t\tif (verifyVacancy(DIR.down, xAxis.default)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.down, xAxis.default);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.default, nextColl + DIR.down);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t} else {\n\t\t\tblock.className = 'positioned-block';\n\t\t\tmatrix[currentRow][currentColl] = 1;\n\t\t\tresetPositions();\n\t\t\tclearInterval(movingBlock);\n\t\t\tstart();\n\t\t}\n\t} else {\n\t\tclearInterval(movingBlock);\n\t\tplay = true;\n\t}\n}\n\n// verify if the next position in a certain direction is open\nfunction verifyVacancy(direction, goBack) {\n\tif (currentRow < maxRow && currentColl + direction >= minColl && currentColl + direction <= maxColl) {\n\t\tif (isPositionOpen(direction, goBack)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\n moves the element to a specified direction\n @currentBlock - the last elment genereted.\n @direction - specifies the direction of the block\n @goBack - specifies the number of rows rows to which a block is set back\n*/\nfunction moveTo(currentBlock, direction, goBack) {\n\tif (typeof currentBlock === 'undefined' || currentBlock === null) {\n\t\tthrow new Error(\"Block is not defined!\");\n\t}\n\tif (typeof direction === 'undefined' || direction === null) {\n\t\tthrow new Error(\"The direction isn't specified!\");\n\t}\n\tif (typeof goBack === 'undefined' || goBack === null) {\n\t\tgoBack = 0;\n\t}\n\tvar newBlock = document.createElement('div');\n\tnewBlock.className = 'active-block';\n\tnewBlock.style.background = block.style.background;\n\n\t// set a trace in the matrix\n\tmatrix[currentRow][currentColl] = 2;\n\tlastX = currentColl;\n\tlastY = currentRow;\n\tnextAvailableCell = getnextAvailableCell(direction, goBack);\n\t//lastOccupiedCell = getnextAvailableCell(direction, goBack);\n\n\tnextAvailableCell.appendChild(newBlock);\n}\n\n// this function removes the first child element from a specified position of the table.\n// used to delete the last position of the block.\nfunction deleteLastPosition() {\n\t//delete the trace of the block in the matrix\n\tmatrix[lastY][lastX] = 0;\n\tvar parent = document.getElementsByClassName('coll-' + lastX)[lastY - 1];\n\tparent.removeChild(parent.children[0]);\n}\n/*\n \tfunction checks if a targeted position is empty\n \t@direction - specifies the direction of the block\n \t@goBack - specifies if the block should go back one row\n*/\nfunction isPositionOpen(direction, goBack) {\n\tif (matrix[nextRow][nextColl + direction] === 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* setting the global variables for the blocks position*/\nfunction setThePositions(currentR, currentC, nextR, nextC, incrNextRow, incrNextColl) {\n\tif (currentR && currentC && currentR !== null && currentC !== null) {\n\t\tlastRow = currentR;\n\t\tlastColl = currentC;\n\t}\n\tif (nextR && nextC && nextR !== null && nextC !== null) {\n\t\tcurrentRow = nextR;\n\t\tcurrentColl = nextC;\n\t}\n\tif (incrNextRow && incrNextColl && incrNextRow !== null && incrNextColl !== null) {\n\t\tnextRow = incrNextRow;\n\t\tnextColl = incrNextColl;\n\t} else {\n\t\tnextRow = currentRow + 1;\n\t\tnextColl = currentColl;\n\t}\n}\n\n/*\n  returns an td element which represents the next position\n  @direction - specifies the direction of the block\n  @goBack - specifies if the block should go back one row\n*/\nfunction getnextAvailableCell(direction, goBack) {\n\tif (typeof direction === 'undefined' || direction === null) {\n\t\tdirection = 0;\n\t}\n\tif (typeof goBack === 'undefined' || goBack === null) {\n\t\tgoBack = 0;\n\t}\n\treturn document.getElementsByClassName('coll-' + (nextColl + direction))[nextRow - goBack - 1];\n}\n\n/*\n  generate a index which will point to a specific position in an array with hex colors as strings\n*/\nfunction generateBackgroundColor() {\n\tvar color,\n\t    randNr = randomNumber(0, 4);\n\tcolor = colors[randNr];\n\treturn color;\n}\n\n/* resets the positions to the initial values */\nfunction resetPositions() {\n\tcurrentRow = startingRow;\n\tcurrentColl = startingColl;\n\tlastRow = startingRow;\n\tlastColl = startingColl;\n\tnextRow = startingRow + 1;\n\tnextColl = startingColl;\n}\n\n// the function checks if the game is over\nfunction isGameOver() {\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tif (matrix[1][i] === 1) {\n\t\t\talert(\"Game Over\");\n\t\t\tdetachEvents();\n\t\t\tplay = false;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// checks if the last row is full\nfunction checkForFullRow() {\n\tvar full = true;\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tif (matrix[maxRow][i] !== 1) full = false;\n\t}\n\tif (full) {\n\t\tclearLastRow();\n\t\trepositionBlocks();\n\t}\n}\n\n// clears the last row\n// triggered if the last row is full\nfunction clearLastRow() {\n\t//clear matrix last row\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tmatrix[maxRow][i] = 0;\n\t}\n\t//clear DOM table last row\n\tvar theLastRow = document.getElementsByClassName('rows')[maxRow - 1];\n\tfor (var j = minColl - 1; j < maxColl; j++) {\n\t\tvar td = theLastRow.children[j];\n\t\ttd.removeChild(td.children[0]);\n\t}\n}\n\n// reposition all the blocks with one position lower after clearing the last row\nfunction repositionBlocks() {\n\tvar sourceRow, destRow, sourceColl, destColl;\n\tfor (var i = maxRow - 2; i >= 1; i--) {\n\t\tsourceRow = document.getElementsByClassName('rows')[i];\n\t\tdestRow = document.getElementsByClassName('rows')[i + 1];\n\t\tfor (var j = minColl - 1; j < maxColl; j++) {\n\t\t\tsourceColl = sourceRow.children[j];\n\t\t\tif (sourceColl.children.length > 0) {\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 2][j + 1] = 1;\n\t\t\t\t// append the block from the upper element to the one positioned lower\n\t\t\t\tdestColl = destRow.children[j];\n\t\t\t\tdestColl.appendChild(sourceColl.children[0]);\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 1][j + 1] = 0;\n\t\t\t} else {\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 2][j + 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction randomNumber(minVal, maxVal) {\n\treturn Math.round(Math.random() * (maxVal - minVal + 1) + minVal);\n}\n\nfunction detachEvents() {\n\tdocument.getElementById('start').removeEventListener('click', start);\n\tdocument.getElementById('stop').removeEventListener('click', stop);\n\tdocument.removeEventListener('keydown', changeDirection);\n}\n//# sourceMappingURL=script.js.map\n//# sourceMappingURL=babeScript.js.map\n'use strict';\n\n(function () {\n\tvar startButton = document.getElementById('start');\n\tstartButton.addEventListener('click', start);\n\tvar stopButton = document.getElementById('stop');\n\tstopButton.addEventListener('click', stop);\n\t// adding the event for key press\n\tdocument.addEventListener('keydown', changeDirection);\n\tgenMatrix();\n})();\n\nvar play = true,\n    DIR = { left: -1, down: 0, right: 1 },\n\n\n// directions\nxAxis = { back: 1, default: 0 },\n\n\n// values for verical movement\nintervalTime = 800,\n\n\n// the period of time for an interval function call\n\nblock,\n\n\n// the current moving block\nmovingBlock,\n\n\n// for the repositioning the block after a certain time interval\n\n// used to trace the block, (using indexes to identify the right position easier)\nstartingRow = 1,\n    startingColl = 6,\n    currentRow = 1,\n    currentColl = 6,\n    lastRow = 1,\n    lastColl = 6,\n    nextRow = 2,\n    nextColl = 6,\n\n\n// positions in the matrix\nlastX = 6,\n    lastY = 1,\n    startingPoz = document.getElementsByClassName('coll-' + startingColl)[0],\n\n\n// this is a column in the first row of the table\nlastPoz,\n\n\n// the last position of the moving block\nnextAvailableCell,\n\n\n// the next available cell for the moving block\nlastOccupiedCell,\n\n\n// the last occupied cell for the moving block\n// global vars\nmaxRow = 15,\n    maxColl = 10,\n    minColl = 1,\n    matrix = [],\n\n\n// colors for the blocks background\ncolors = ['#be0000', '#becf00', '#2cbe00', '#001ebe', '#be009a']; // the colors of the moving block\nvar omon = \"2131\";\n\nfunction genMatrix() {\n\tvar i, j;\n\tfor (i = 1; i <= maxRow; i++) {\n\t\tmatrix[i] = [];\n\t\tfor (j = 1; j <= maxColl; j++) {\n\t\t\tmatrix[i][j] = 0;\n\t\t}\n\t}\n}\n\nfunction start() {\n\tplay = true;\n\tif (matrix.length === 0) {\n\t\tgenMatrix();\n\t}\n\tcheckForFullRow();\n\tblock = generateBlock();\n\tmovingBlock = setInterval(reposition, intervalTime);\n}\n\nfunction stop() {\n\tplay = false;\n\tlastY += 1;\n\tdeleteLastPosition();\n\talert(\"Game stoped!\");\n}\n\n/*\n\tThe function creates a block, and sets a color to the block before appending\n\tit to the starting position of the board\n*/\nfunction generateBlock() {\n\tblockGen = document.createElement('div');\n\tblockGen.className = 'active-block';\n\tblockGen.style.background = generateBackgroundColor();\n\tstartingPoz.appendChild(blockGen);\n\tnextAvailableCell = getnextAvailableCell(DIR.down, xAxis.default);\n\n\tsetThePositions(startingRow, startingColl, startingRow, startingColl);\n\n\treturn blockGen;\n}\n\n/*\n\tthe function starts when a key is pressed and it directs a particular event to a coresponding case\n*/\nfunction changeDirection(event) {\n\tevent = event || window.event;\n\t//clearInterval(movingBlock);\n\tif (event.keyCode == '37') {\n\t\t// left arrow\n\t\tif (verifyVacancy(DIR.left, xAxis.back)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.left, xAxis.back);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.back, nextColl + DIR.left, nextRow, nextColl + DIR.left);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t} else if (event.keyCode == '39') {\n\t\t// right arrow\n\t\tif (verifyVacancy(DIR.right, xAxis.back)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.right, xAxis.back);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.back, nextColl + DIR.right, nextRow, nextColl + DIR.right);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t} else if (event.keyCode == '40') {\n\t\t// down arrow\n\t\tif (verifyVacancy(DIR.down, xAxis.default)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.down, xAxis.default);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.default, nextColl + DIR.down);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t}\n}\n/*\n\tif there is an available position next the function will reposition the block,\n\totherwise it will clear the last position and create a new block from the beginning\n*/\nfunction reposition() {\n\n\tif (play && isGameOver() === true) {\n\t\tif (verifyVacancy(DIR.down, xAxis.default)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.down, xAxis.default);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.default, nextColl + DIR.down);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t} else {\n\t\t\tblock.className = 'positioned-block';\n\t\t\tmatrix[currentRow][currentColl] = 1;\n\t\t\tresetPositions();\n\t\t\tclearInterval(movingBlock);\n\t\t\tstart();\n\t\t}\n\t} else {\n\t\tclearInterval(movingBlock);\n\t\tplay = true;\n\t}\n}\n\n// verify if the next position in a certain direction is open\nfunction verifyVacancy(direction, goBack) {\n\tif (currentRow < maxRow && currentColl + direction >= minColl && currentColl + direction <= maxColl) {\n\t\tif (isPositionOpen(direction, goBack)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\n moves the element to a specified direction\n @currentBlock - the last elment genereted.\n @direction - specifies the direction of the block\n @goBack - specifies the number of rows rows to which a block is set back\n*/\nfunction moveTo(currentBlock, direction, goBack) {\n\tif (typeof currentBlock === 'undefined' || currentBlock === null) {\n\t\tthrow new Error(\"Block is not defined!\");\n\t}\n\tif (typeof direction === 'undefined' || direction === null) {\n\t\tthrow new Error(\"The direction isn't specified!\");\n\t}\n\tif (typeof goBack === 'undefined' || goBack === null) {\n\t\tgoBack = 0;\n\t}\n\tvar newBlock = document.createElement('div');\n\tnewBlock.className = 'active-block';\n\tnewBlock.style.background = block.style.background;\n\n\t// set a trace in the matrix\n\tmatrix[currentRow][currentColl] = 2;\n\tlastX = currentColl;\n\tlastY = currentRow;\n\tnextAvailableCell = getnextAvailableCell(direction, goBack);\n\t//lastOccupiedCell = getnextAvailableCell(direction, goBack);\n\n\tnextAvailableCell.appendChild(newBlock);\n}\n\n// this function removes the first child element from a specified position of the table.\n// used to delete the last position of the block.\nfunction deleteLastPosition() {\n\t//delete the trace of the block in the matrix\n\tmatrix[lastY][lastX] = 0;\n\tvar parent = document.getElementsByClassName('coll-' + lastX)[lastY - 1];\n\tparent.removeChild(parent.children[0]);\n}\n/*\n \tfunction checks if a targeted position is empty\n \t@direction - specifies the direction of the block\n \t@goBack - specifies if the block should go back one row\n*/\nfunction isPositionOpen(direction, goBack) {\n\tif (matrix[nextRow][nextColl + direction] === 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* setting the global variables for the blocks position*/\nfunction setThePositions(currentR, currentC, nextR, nextC, incrNextRow, incrNextColl) {\n\tif (currentR && currentC && currentR !== null && currentC !== null) {\n\t\tlastRow = currentR;\n\t\tlastColl = currentC;\n\t}\n\tif (nextR && nextC && nextR !== null && nextC !== null) {\n\t\tcurrentRow = nextR;\n\t\tcurrentColl = nextC;\n\t}\n\tif (incrNextRow && incrNextColl && incrNextRow !== null && incrNextColl !== null) {\n\t\tnextRow = incrNextRow;\n\t\tnextColl = incrNextColl;\n\t} else {\n\t\tnextRow = currentRow + 1;\n\t\tnextColl = currentColl;\n\t}\n}\n\n/*\n  returns an td element which represents the next position\n  @direction - specifies the direction of the block\n  @goBack - specifies if the block should go back one row\n*/\nfunction getnextAvailableCell(direction, goBack) {\n\tif (typeof direction === 'undefined' || direction === null) {\n\t\tdirection = 0;\n\t}\n\tif (typeof goBack === 'undefined' || goBack === null) {\n\t\tgoBack = 0;\n\t}\n\treturn document.getElementsByClassName('coll-' + (nextColl + direction))[nextRow - goBack - 1];\n}\n\n/*\n  generate a index which will point to a specific position in an array with hex colors as strings\n*/\nfunction generateBackgroundColor() {\n\tvar color,\n\t    randNr = randomNumber(0, 4);\n\tcolor = colors[randNr];\n\treturn color;\n}\n\n/* resets the positions to the initial values */\nfunction resetPositions() {\n\tcurrentRow = startingRow;\n\tcurrentColl = startingColl;\n\tlastRow = startingRow;\n\tlastColl = startingColl;\n\tnextRow = startingRow + 1;\n\tnextColl = startingColl;\n}\n\n// the function checks if the game is over\nfunction isGameOver() {\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tif (matrix[1][i] === 1) {\n\t\t\talert(\"Game Over\");\n\t\t\tdetachEvents();\n\t\t\tplay = false;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// checks if the last row is full\nfunction checkForFullRow() {\n\tvar full = true;\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tif (matrix[maxRow][i] !== 1) full = false;\n\t}\n\tif (full) {\n\t\tclearLastRow();\n\t\trepositionBlocks();\n\t}\n}\n\n// clears the last row\n// triggered if the last row is full\nfunction clearLastRow() {\n\t//clear matrix last row\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tmatrix[maxRow][i] = 0;\n\t}\n\t//clear DOM table last row\n\tvar theLastRow = document.getElementsByClassName('rows')[maxRow - 1];\n\tfor (var j = minColl - 1; j < maxColl; j++) {\n\t\tvar td = theLastRow.children[j];\n\t\ttd.removeChild(td.children[0]);\n\t}\n}\n\n// reposition all the blocks with one position lower after clearing the last row\nfunction repositionBlocks() {\n\tvar sourceRow, destRow, sourceColl, destColl;\n\tfor (var i = maxRow - 2; i >= 1; i--) {\n\t\tsourceRow = document.getElementsByClassName('rows')[i];\n\t\tdestRow = document.getElementsByClassName('rows')[i + 1];\n\t\tfor (var j = minColl - 1; j < maxColl; j++) {\n\t\t\tsourceColl = sourceRow.children[j];\n\t\t\tif (sourceColl.children.length > 0) {\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 2][j + 1] = 1;\n\t\t\t\t// append the block from the upper element to the one positioned lower\n\t\t\t\tdestColl = destRow.children[j];\n\t\t\t\tdestColl.appendChild(sourceColl.children[0]);\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 1][j + 1] = 0;\n\t\t\t} else {\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 2][j + 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction randomNumber(minVal, maxVal) {\n\treturn Math.round(Math.random() * (maxVal - minVal + 1) + minVal);\n}\n\nfunction detachEvents() {\n\tdocument.getElementById('start').removeEventListener('click', start);\n\tdocument.getElementById('stop').removeEventListener('click', stop);\n\tdocument.removeEventListener('keydown', changeDirection);\n}\n//# sourceMappingURL=script.js.map\n//# sourceMappingURL=babeScript.js.map\n'use strict';\n\n(function () {\n\tvar startButton = document.getElementById('start');\n\tstartButton.addEventListener('click', start);\n\tvar stopButton = document.getElementById('stop');\n\tstopButton.addEventListener('click', stop);\n\t// adding the event for key press\n\tdocument.addEventListener('keydown', changeDirection);\n\tgenMatrix();\n})();\n\nvar play = true,\n    DIR = { left: -1, down: 0, right: 1 },\n\n// directions\nxAxis = { back: 1, default: 0 },\n\n// values for verical movement\nintervalTime = 800,\n\n// the period of time for an interval function call\n\nblock,\n\n// the current moving block\nmovingBlock,\n\n// for the repositioning the block after a certain time interval\n\n// used to trace the block, (using indexes to identify the right position easier)\nstartingRow = 1,\n    startingColl = 6,\n    currentRow = 1,\n    currentColl = 6,\n    lastRow = 1,\n    lastColl = 6,\n    nextRow = 2,\n    nextColl = 6,\n\n\n// positions in the matrix\nlastX = 6,\n    lastY = 1,\n    startingPoz = document.getElementsByClassName('coll-' + startingColl)[0],\n\n// this is a column in the first row of the table\nlastPoz,\n\n// the last position of the moving block\nnextAvailableCell,\n\n// the next available cell for the moving block\nlastOccupiedCell,\n\n// the last occupied cell for the moving block\n// global vars\nmaxRow = 15,\n    maxColl = 10,\n    minColl = 1,\n    matrix = [],\n\n\n// colors for the blocks background\ncolors = ['#be0000', '#becf00', '#2cbe00', '#001ebe', '#be009a']; // the colors of the moving block\n\nfunction genMatrix() {\n\tvar i, j;\n\tfor (i = 1; i <= maxRow; i++) {\n\t\tmatrix[i] = [];\n\t\tfor (j = 1; j <= maxColl; j++) {\n\t\t\tmatrix[i][j] = 0;\n\t\t}\n\t}\n}\n\nfunction start() {\n\tplay = true;\n\tif (matrix.length === 0) {\n\t\tgenMatrix();\n\t}\n\tcheckForFullRow();\n\tblock = generateBlock();\n\tmovingBlock = setInterval(reposition, intervalTime);\n}\n\nfunction stop() {\n\tplay = false;\n\tlastY += 1;\n\tdeleteLastPosition();\n\talert(\"Game stoped!\");\n}\n\n/*\n\tThe function creates a block, and sets a color to the block before appending\n\tit to the starting position of the board\n*/\nfunction generateBlock() {\n\tblockGen = document.createElement('div');\n\tblockGen.className = 'active-block';\n\tblockGen.style.background = generateBackgroundColor();\n\tstartingPoz.appendChild(blockGen);\n\tnextAvailableCell = getnextAvailableCell(DIR.down, xAxis.default);\n\n\tsetThePositions(startingRow, startingColl, startingRow, startingColl);\n\n\treturn blockGen;\n}\n\n/*\n\tthe function starts when a key is pressed and it directs a particular event to a coresponding case\n*/\nfunction changeDirection(event) {\n\tevent = event || window.event;\n\t//clearInterval(movingBlock);\n\tif (event.keyCode == '37') {\n\t\t// left arrow\n\t\tif (verifyVacancy(DIR.left, xAxis.back)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.left, xAxis.back);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.back, nextColl + DIR.left, nextRow, nextColl + DIR.left);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t} else if (event.keyCode == '39') {\n\t\t// right arrow\n\t\tif (verifyVacancy(DIR.right, xAxis.back)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.right, xAxis.back);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.back, nextColl + DIR.right, nextRow, nextColl + DIR.right);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t} else if (event.keyCode == '40') {\n\t\t// down arrow\n\t\tif (verifyVacancy(DIR.down, xAxis.default)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.down, xAxis.default);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.default, nextColl + DIR.down);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t}\n\t}\n}\n/*\n\tif there is an available position next the function will reposition the block,\n\totherwise it will clear the last position and create a new block from the beginning\n*/\nfunction reposition() {\n\n\tif (play && isGameOver() === true) {\n\t\tif (verifyVacancy(DIR.down, xAxis.default)) {\n\t\t\ttry {\n\t\t\t\tmoveTo(block, DIR.down, xAxis.default);\n\t\t\t\tsetThePositions(currentRow, currentColl, nextRow - xAxis.default, nextColl + DIR.down);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t\tdeleteLastPosition();\n\t\t} else {\n\t\t\tblock.className = 'positioned-block';\n\t\t\tmatrix[currentRow][currentColl] = 1;\n\t\t\tresetPositions();\n\t\t\tclearInterval(movingBlock);\n\t\t\tstart();\n\t\t}\n\t} else {\n\t\tclearInterval(movingBlock);\n\t\tplay = true;\n\t}\n}\n\n// verify if the next position in a certain direction is open\nfunction verifyVacancy(direction, goBack) {\n\tif (currentRow < maxRow && currentColl + direction >= minColl && currentColl + direction <= maxColl) {\n\t\tif (isPositionOpen(direction, goBack)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*\n moves the element to a specified direction\n @currentBlock - the last elment genereted.\n @direction - specifies the direction of the block\n @goBack - specifies the number of rows rows to which a block is set back\n*/\nfunction moveTo(currentBlock, direction, goBack) {\n\tif (typeof currentBlock === 'undefined' || currentBlock === null) {\n\t\tthrow new Error(\"Block is not defined!\");\n\t}\n\tif (typeof direction === 'undefined' || direction === null) {\n\t\tthrow new Error(\"The direction isn't specified!\");\n\t}\n\tif (typeof goBack === 'undefined' || goBack === null) {\n\t\tgoBack = 0;\n\t}\n\tvar newBlock = document.createElement('div');\n\tnewBlock.className = 'active-block';\n\tnewBlock.style.background = block.style.background;\n\n\t// set a trace in the matrix\n\tmatrix[currentRow][currentColl] = 2;\n\tlastX = currentColl;\n\tlastY = currentRow;\n\tnextAvailableCell = getnextAvailableCell(direction, goBack);\n\t//lastOccupiedCell = getnextAvailableCell(direction, goBack);\n\n\tnextAvailableCell.appendChild(newBlock);\n}\n\n// this function removes the first child element from a specified position of the table.\n// used to delete the last position of the block.\nfunction deleteLastPosition() {\n\t//delete the trace of the block in the matrix\n\tmatrix[lastY][lastX] = 0;\n\tvar parent = document.getElementsByClassName('coll-' + lastX)[lastY - 1];\n\tparent.removeChild(parent.children[0]);\n}\n/*\n \tfunction checks if a targeted position is empty\n \t@direction - specifies the direction of the block\n \t@goBack - specifies if the block should go back one row\n*/\nfunction isPositionOpen(direction, goBack) {\n\tif (matrix[nextRow][nextColl + direction] === 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* setting the global variables for the blocks position*/\nfunction setThePositions(currentR, currentC, nextR, nextC, incrNextRow, incrNextColl) {\n\tif (currentR && currentC && currentR !== null && currentC !== null) {\n\t\tlastRow = currentR;\n\t\tlastColl = currentC;\n\t}\n\tif (nextR && nextC && nextR !== null && nextC !== null) {\n\t\tcurrentRow = nextR;\n\t\tcurrentColl = nextC;\n\t}\n\tif (incrNextRow && incrNextColl && incrNextRow !== null && incrNextColl !== null) {\n\t\tnextRow = incrNextRow;\n\t\tnextColl = incrNextColl;\n\t} else {\n\t\tnextRow = currentRow + 1;\n\t\tnextColl = currentColl;\n\t}\n}\n\n/*\n  returns an td element which represents the next position\n  @direction - specifies the direction of the block\n  @goBack - specifies if the block should go back one row\n*/\nfunction getnextAvailableCell(direction, goBack) {\n\tif (typeof direction === 'undefined' || direction === null) {\n\t\tdirection = 0;\n\t}\n\tif (typeof goBack === 'undefined' || goBack === null) {\n\t\tgoBack = 0;\n\t}\n\treturn document.getElementsByClassName('coll-' + (nextColl + direction))[nextRow - goBack - 1];\n}\n\n/*\n  generate a index which will point to a specific position in an array with hex colors as strings\n*/\nfunction generateBackgroundColor() {\n\tvar color,\n\t    randNr = randomNumber(0, 4);\n\tcolor = colors[randNr];\n\treturn color;\n}\n\n/* resets the positions to the initial values */\nfunction resetPositions() {\n\tcurrentRow = startingRow;\n\tcurrentColl = startingColl;\n\tlastRow = startingRow;\n\tlastColl = startingColl;\n\tnextRow = startingRow + 1;\n\tnextColl = startingColl;\n}\n\n// the function checks if the game is over\nfunction isGameOver() {\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tif (matrix[1][i] === 1) {\n\t\t\talert(\"Game Over\");\n\t\t\tdetachEvents();\n\t\t\tplay = false;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// checks if the last row is full\nfunction checkForFullRow() {\n\tvar full = true;\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tif (matrix[maxRow][i] !== 1) full = false;\n\t}\n\tif (full) {\n\t\tclearLastRow();\n\t\trepositionBlocks();\n\t}\n}\n\n// clears the last row\n// triggered if the last row is full\nfunction clearLastRow() {\n\t//clear matrix last row\n\tfor (var i = minColl; i <= maxColl; i++) {\n\t\tmatrix[maxRow][i] = 0;\n\t}\n\t//clear DOM table last row\n\tvar theLastRow = document.getElementsByClassName('rows')[maxRow - 1];\n\tfor (var j = minColl - 1; j < maxColl; j++) {\n\t\tvar td = theLastRow.children[j];\n\t\ttd.removeChild(td.children[0]);\n\t}\n}\n\n// reposition all the blocks with one position lower after clearing the last row\nfunction repositionBlocks() {\n\tvar sourceRow, destRow, sourceColl, destColl;\n\tfor (var i = maxRow - 2; i >= 1; i--) {\n\t\tsourceRow = document.getElementsByClassName('rows')[i];\n\t\tdestRow = document.getElementsByClassName('rows')[i + 1];\n\t\tfor (var j = minColl - 1; j < maxColl; j++) {\n\t\t\tsourceColl = sourceRow.children[j];\n\t\t\tif (sourceColl.children.length > 0) {\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 2][j + 1] = 1;\n\t\t\t\t// append the block from the upper element to the one positioned lower\n\t\t\t\tdestColl = destRow.children[j];\n\t\t\t\tdestColl.appendChild(sourceColl.children[0]);\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 1][j + 1] = 0;\n\t\t\t} else {\n\t\t\t\t// modify the matrix\n\t\t\t\tmatrix[i + 2][j + 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction randomNumber(minVal, maxVal) {\n\treturn Math.round(Math.random() * (maxVal - minVal + 1) + minVal);\n}\n\nfunction detachEvents() {\n\tdocument.getElementById('start').removeEventListener('click', start);\n\tdocument.getElementById('stop').removeEventListener('click', stop);\n\tdocument.removeEventListener('keydown', changeDirection);\n}\n//# sourceMappingURL=script.js.map\n//# sourceMappingURL=babelScript.js.map\n"],"sourceRoot":"/source/"}